import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.RobotBase;
import edu.wpi.first.wpilibj.vision.VisionThread;
import org.opencv.core.*;
import org.opencv.imgproc.Imgproc;

import java.util.ArrayList;
import java.util.List;

public class Robot extends RobotBase {

    private CameraServer cameraServer;
    private VisionThread visionThread;
    private Mat frame;
    private List<MatOfPoint> contours;

    private static final Scalar LOWER_ORANGE = new Scalar(0, 150, 100);
    private static final Scalar UPPER_ORANGE = new Scalar(10, 255, 255);
    private static final double KNOWN_WIDTH_INCHES = 10.0;
    private static final double FOCAL_LENGTH = 320.8;

    public Robot() {
        frame = new Mat();
        contours = new ArrayList<>();
    }

    @Override
    public void robotInit() {
        cameraServer = CameraServer.getInstance();
        cameraServer.startAutomaticCapture();

        visionThread = new VisionThread(cameraServer.getVideo(), new GripPipeline(), pipeline -> {
            // Process the frame using the GripPipeline (auto-generated by GRIP)
            frame = pipeline.cvResizeOutput();
            detectOrangeTorus(frame, LOWER_ORANGE, UPPER_ORANGE);

            // Display the processed frame on the dashboard
            cameraServer.putFrame(frame);
        });

        visionThread.start();
    }

    private void detectOrangeTorus(Mat frame, Scalar lower, Scalar upper) {
        Mat hsvFrame = new Mat();
        Imgproc.cvtColor(frame, hsvFrame, Imgproc.COLOR_BGR2HSV);

        Mat mask = new Mat();
        Core.inRange(hsvFrame, lower, upper, mask);

        Mat blurredMask = new Mat();
        Imgproc.GaussianBlur(mask, blurredMask, new Size(5, 5), 0);

        Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, new Size(5, 5));
        Mat smoothedMask = new Mat();
        Imgproc.morphologyEx(blurredMask, smoothedMask, Imgproc.MORPH_OPEN, kernel);
        Imgproc.morphologyEx(smoothedMask, smoothedMask, Imgproc.MORPH_CLOSE, kernel);

        Core.bitwise_and(frame, frame, frame, smoothedMask);

        // Find contours
        contours.clear();
        Imgproc.findContours(smoothedMask, contours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);

        // Filter contours based on size or other criteria
        List<MatOfPoint> filteredContours = new ArrayList<>();
        for (MatOfPoint contour : contours) {
            if (Imgproc.contourArea(contour) > 100) {
                filteredContours.add(contour);
            }
        }

        // Draw bounding box
        drawBoundingBox(frame, filteredContours, new Scalar(0, 255, 0));

        // Distance estimation logic
        if (!filteredContours.isEmpty()) {
            double apparentWidth = measureLongestSide(filteredContours.get(0));
            double distance = estimateDistance(apparentWidth, KNOWN_WIDTH_INCHES, FOCAL_LENGTH);
            System.out.println("Distance: " + distance + " inches");
        }
    }

    private void drawBoundingBox(Mat frame, List<MatOfPoint> contours, Scalar color) {
        for (MatOfPoint contour : contours) {
            Rect boundingRect = Imgproc.boundingRect(contour);
            Imgproc.rectangle(frame, boundingRect.tl(), boundingRect.br(), color, 2);
        }
    }

    private double estimateDistance(double apparentWidth, double knownWidth, double focalLength) {
        return (knownWidth * focalLength) / apparentWidth;
    }

    private double measureLongestSide(MatOfPoint contour) {
        Rect boundingRect = Imgproc.boundingRect(contour);
        return Math.max(boundingRect.width, boundingRect.height);
    }

    public static void main(String... args) {
        Robot robot = new Robot();
        robot.startCompetition();
    }
}
